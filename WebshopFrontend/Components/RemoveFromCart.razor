@using System.Diagnostics
@using WebshopCore
@using WebshopCore.Dtos
@rendermode InteractiveServer
@inject IHttpClientFactory HttpClientFactory
@inject Blazored.LocalStorage.ILocalStorageService LocalStorage

<i class="bi bi-trash3 remove-icon" @onclick="() => RemoveFromCartAsync(Product)"></i>

@code {
    private List<OrderItemDto> _cart = new();

    [Parameter]
    public required BookDto Product { get; set; }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        _cart = await GetItemsFromCartAsync();
        StateHasChanged();
    }

    private async Task<List<OrderItemDto>> GetItemsFromCartAsync()
    {
        return await LocalStorage.GetItemAsync<List<OrderItemDto>>("cart") ?? new List<OrderItemDto>();
    }

    private async Task RemoveFromCartAsync(BookDto product)
    {
        _cart = await GetItemsFromCartAsync();
        
        // not an ideal solution, but it works
        // currently each product is added as a separate item in the cart list, and finding the item to remove it finds the first one and removes it.
        // which means if the same product is added multiple times, the first one will be removed even if you click on the remove button of the second one.
        var productToRemove = _cart.FirstOrDefault(p => p.Book.Id == product.Id);
        if (productToRemove != null)
        {
            if (productToRemove.Quantity > 1)
            {
                productToRemove.Quantity--;
            }
            else
            {
                _cart.Remove(productToRemove);
            }
        }
           // _cart.Remove(productToRemove);

        await LocalStorage.SetItemAsync("cart", _cart);

        using var client = HttpClientFactory.CreateClient("WebshopBackendAPI");
        var response = await client.PatchAsync($"/increaseAvailableQty/{Product.Id}", null);
    }
}
